# BASE APP(ru)

Это описание нашего базового приложения. Оно научит вас работать с тем кодом, который мы делаем у нас в ProCode. Даже если вы не будете использовать наше базовое приложение, можно использовать это руководство как примеры архитектурных приемов. Однако, помните, это наше базовое приложение и оно заточено под то как пишем мы. Если кто-то пишет иначе, это не значит что наш или его код и архитектурные решения хуже, это просто другой вариант реализации и оценивать его надо комплексно, учитывая что написано вокруг(с какими приемами оно работает вместе), историю компании, специализацию и квалификацию и какие именно проекты делает компания.

Документ написан в формате markdown. Если у вас сложности в его чтением - используйте онлайн редакторы markdown для более комфортного чтения.

## Какие доработки нужны на сегодня?

* Ротация логов. В связи с новым логером, эта функция еще не настроена
* Упрощенный вывод логов запросов при разработке
* Мидлвейр авторизации не доделан.
* Мидлвейрроутинга для вебсокетов
* Нет ранера с мигратором бд (для первичного заполнения бд)

## Формат роутов

Вам не обязательно делать SEO дружественные ссылки. Так как мы используем front-end роутинг, то SEO нужно учитывать там, а для BACK-end без разницы что будет по сылкам в плане SEO, но они должны быть понятны для программистов которые будут их использовать.

### Примеры

Простые запросы, где надо получить что-то конктретное по его айди в базе.
> GET /категория_того_что_получаем/действие/айдишник

как вариант:
> GET /comments/getById/12345678
> GET /comments/getByUser/12345678
> GET /comments/getByUser/12345678

Это будет похоже на структуру вашей бд, они не обязательно должны быть один в один. Старайтесь делать так, чтобы другой программист с первого взгляда мог понять что это за запрос.

### Связанные данные

Иногда может показаться что одни данные должны лежать в других. Например есть статья, у статьи есть коментарии. Казалось бы, я должен получить коментарии и статью вместе, но в тожде время может быть два отдельных роута /articles и /comments. Что делать?

* Вы можете по умолчанию передавать коментарии как часть ответа на запрос статьи. Для предотвращения переизбытка даных, стоит добавить возможность уточнять что имено вам нужно. Такой метод используют гугловские апи и многие другие.
* Можно реализовать отдельную подгрузку коментариев. Это может показаться странным, но часто бывает важным отобразить пользователю контент как можно раньше, используя более быстрый запрос, а дополнительный контент, в данном случае комменты, можно и позже подгрузить.

Оба метожа можно использовать одновременно. Их используют во многих апи, например в гуговской апи это есть.

### Справочный формат

> GET /тип_того_что получаем/действие/[айдишник][?параметры]

_**тип_того_что получаем**_
предпочтительно использвать слова в множестве, users, comments. Не user, comment. Важно чтобы было одинаково, а если вы то так, то так пишите, выйдет два разных префикса. Некоторые слова не имеют множества, или имеют устоявщиеся формы, например auth. Это сокращение от слова authorization, обозначающее процес, тут можно и без множества. Если сомневаетесь - пишите множество, колеги попаравят если что.

_**действие**_
собствено что вы делаете. Например getByUId.

Предпочтительно использовать описание действия, что было понятно что они делаеют. Исключение только предыдущий случай, когда запрос по айди. Это просто дань традиции. Все так привыкли и понимают что это, только потому что это очень распостраненная вешь, мы учитываем ее. Не передавате параметры в урл(те что потом оказываются в res.query, так называемые GET параметры). Например, GET /articles/getByTags, по названию можно понять что это скорее всего статьи по тегам. Сами теги вы передаете в теле запроса. Теретически если бы мы запрашивали статью по айди, следуя тем же правилам, то это было бы GET /articles/getById и айди был бы в теле запроса, но для айди и только для айди, мы пишем GET /articles/:ID. Другие традиции мы зачастую игнорируем отдавая предпочтение стандартизации, да и когда все данные в теле запроса.

* Исключение! По историческим причинам, getById может пропускаться, тоесть после категории может быть написан сразу айди. Такой сокращенный формат действует только для getById. Никаких особых причин для такого исключения нет, просто многие привыкли имено к такому еще с бекенд роутинга, когда любили делать простые ссылки. Это просто дань традиции. Не бойтесь что названия функций можно перепутать с айди. Названия функций это английские слова, они мало похожи на циферно-буквенный набор, классический для айдишников. Но для публичных апи это лучше не использовать, всетаки одно дело для себя, другое когда это пытаеться разобрать неизвестный программист. В этом случае все должно быть максимально одинаково.

_**айдишник**_
Позволяет однозначно идентифицыровать запись. Иногда его может не быть. Например, если действие было getAll. В таком случае какой айдишник, если запросили все?

_**параметры**_
Уточнения, параметры. Например пагинация, но не айди.
Айди вынесен с параметров для однозначной идентификации что это. Это может в дальшейшем пригодиться для логов или для SEO, если по какимто причинам у вас бекенд роутинг

Примеры:
| метод | ссылка                            | что делает?                                                                 |
| --    | --                                | --                                                                          |
| GET   | /users/getById/12                 | дай мне профиль юзера с айди 12                                             |
| GET   | /users/12                         | тоже самое, но пропущен getById, сокращенный формат.                        |
| GET   | /articles/getById/10              | дай мне статью с айди 10                                                    |
| GET   | /comments/getByArticleID/10       | дай мне комменты к статье с айди 10                                         |
| GET   | /orders/getById/5e6bdd54da9a98c46cb312f4  | заказ с айди 5e6bdd54da9a98c46cb312f4. Внешний вид айдишника неважен, главное это айдишник. Некоторые программисты бояться что сылка может стать некрасивой, помните, красиво и для SEO это на фронтенд роутенинге. А тут вы делаете для программистов, и важна семантика, что бы было понятно что это и откуда береться |
| GET   | /articles/getByDate?date=20/12/2020       | тоже можно использовать как "дай мне список по дате", а в теле запроса добавить параметры. Можно и в query передать параметры, но какой смысл то там то там передавать параметры                 |
| GET   | /articles/list                   | дай мне список статей, можно и /article/getList, но просто лист традицыонный роут для нашей компании. Многие компании используют просто GET /articles/, но не мы. GET /article/ тоже обычно расшифровываеться как "дай мне список статей", но бывыет что списки разные или куча функций и такие ссылки не выглядят органично с остальными функциями, потому мы чаще используем роут вида /articles/list. /articles/list это впринцыпе одно и тоже /articles/getAll                                                                                                     |

Роуты которые что-то меняют или создают, используют метод POST. Принцыпы построение теже самые что и для роутов которые получают данные. Исключение для айди мы не делаем, потому что POST /article/:ID может быть как и создать статью, так и изменить статью, потому вместо этого мы пишем конкренто POST /article/create или POST /article/update, а айди, если есть, передаем в теле запроса.

Примеры:
| метод | ссылка                   | что делает?                                                                     |
| --    | --                       | --                                                                              |
| POST | /articles/create          | создай статью, в теле запроса передаем текст статьи и другие параметры          |
| POST | /comments/create          | создай коммент, например к статье. В теле запроса передаем что создаем и для чего. Некоторые делают что-то вроде /articles/comments/create, обычно мы не используем такие вложенные конструкции, так как комент это комент, он может быть к чему угодно и нет смысла его привязывать урлом к статье и заранее ставить себе палки в колеса, если этого можно не делать.                                                                                         |
| POST | /commentsDeal/create      | если у вас есть например какието "особо-особенные" коменты, создайте отдельный роут для него, но только если он реально сильно отличаеться. Не стоит плодить дополнительные сущности, если от их наличия, читабельность кода особо не меняеться.                                                                              |

Вы могли заметить, чтот формат роутов не слишком привязан к методам POST и GET. Тот же /comments/create понятен и без приписки POST. Наша компания использует протокол WS на равне с классическим протоколом HTTP. Мы используем там теже правила, и в протоколе WS нет методов вообще.

## Формат ответов

Все ответы сервера для протоколов HTTP и WS, используют стандартизированую форму ответа и формат json

Форма ответа:
| ключ                                                    | варианты                | описание                      |
| ------------------------------------------------------- | ----------------------- | ----------------------------- |
| "status"                                                |                         | Обязательное поле, обозначает  успешность действия которое запустил запрос.                                                                        |
|                                                         | "ok"                    | все хорошо                    |
|                                                         | "error"                 | ошибка (общая)                |
|                                                         | "invalid data"          | ошибка валидации (входящие данные в неправльном формате, уточнение ошибки в "payload")                                                                  |
|                                                         | "invalid token"         | ошибка доступа (что нетак с jwt или правами доступа)                                                                                                    |
| "error"                                                 | текст                   | код ошибки, текстом, расширенная информация об ошибке приходит в payload                                                                             |
| "payload"                                               | объект                  | непосредствено полезная нагрузка отдаваемая в запросе                                                                                                |

Пример 1
{ "status": "ok" } - это обязательный ответ на любой запрос, даже если он не должен отдать что-то в ответ
{ "status": "ok", "payload": { "id": 123456789 } } - ответ "все хорошо" + передача дополнительной информации. Такой ответ может быть к примеру на запрос создания пользователя

### этот же формат рекомендуем для типовых ответов функций в контроллерах

так гораздо меньше преобразований в коде, когда везде все одинаково

Плохо
>....
>try {
>  const data = await decode(token);
>  socket.emit('ответ такой-то');
>  ....
>} catch (err) {
>  socket.emit('Все плохо! А может и норм, только кривой токен.... все в куче же');
>}

в данном случае неуспешность действия и критические ошибки в коде, сделаные программистом, пойдут в одну кучу

хорошо
>....
>try {
>  const data = await decode(token);
>  const { status, payload } = data;
>  if( status !== 'ok' ) {
>    socket.emit('кривой токен');
>  } else {
>    socket.emit('ответ такой-то');
>  }
>} catch (err) {
>  socket.emit('Все плохо!');
>}

в данном случае мы отслеживаем конкретно ситуацию неуспешного выполнения функции, предусмотренное как штатную ситуацию. Не забывайте, что { status: 'ok' } это только формат ретурна для функций,  если вам нужен try .... catch, используйте try .... catch!

#### ад трей кечей
Конечно "ад трей кечей" не вспоминают только потому, что половина людей просто не делают трай кечи. Чтоб не городить лишние конструкции, можно использовать обычный промисовский кетч

> const test = async () => {
>   throw new Error('кудаж ты свой кривой токен пихаешь?');
> }
> ....
> const init = async () => {
>   try {
>     await test().catch((err) => {
>     console.log('CATCH:', err);
>     })
>   } catch (err) {
>     console.log('ERR:', err)
>   }
> }
> init();

В данном случае ошибка будет отображена в console.log('CATCH:', err) и не попадет в общий трайкеч. Также удобно и то что не будут создаваться вложенные области видимости из-за скобок трайкеча.

**Функции возращающие однозначный ответ**
для функций возвращающий однозначный ответ допустимо использовать простые форматы ответов
const sum = (a, b) => {
  const result = a + b;
  return result;
}

Не ложите данные напрямую в payload, создавайте ключи. К примеру, у вас есть запрос "/courses" по которому фронт запрашивает список курсов на учебном портале
Плохо
> {
>   "status": "ok",
>   "payload": [
>     { "id": 123456789, name: "course 1" }, { "id": 123456789, name: "course 1" }
>   ]
> }

Тут в "payload" сразу лежит массив с курсами, что плохо, так как если в будущем вам нужно будет добавить какие либо дополнительные данные, прийдеться менять существующие поля в "payload"

Хорошо
>
> { 
>   "status": "ok",
>   "payload": {
>     "courses": [{ "id": 123456789, name: "course 1" }, { "id": 123456789, name: "course 1" }]
>   }
> }

Это хорошо, так как вы можете свободно добавлять новые ключи в "payload", не меняя уже существующие

## Подробнее про ошибки 
Этот раздел касаеться всех статусов относяшихся к ошибкам, на момент написания документации, любой статус кроме "ok" это ошибки.

_Уточняющая информация об ошибке_
передаеться в ключе payload.error или payload.errors если масив ошибок(например при валидации), формат внутри payload.error при этом согласовываеться отдельно и может быть по сути любым, в зависимости от того, как генерировалась ошибка.

Пример
>
> {
>   status: "invalid data",
>   payload: {
>     errors: [{
>       keyword: "maxItems",
>       dataPath: ".lines[3].coordinates",
>       schemaPath: "#/properties/lines/items/properties/coordinates/maxItems",
>       params: {
>         limit: 2
>       },
>       message: "should NOT have more than 2 items"
>     }]
>   },
> }

В данном случае это формат ошибки валидации json схемы, генерируемый ajv.

Пример 2
> {
>   status: "invalid token",
>   payload: {
>     error: [
>       message: "Bad JWT"
>     }]
>   },
> }

Ошибка проверки JWT. Бек сразу отправил ошибку, не разбираясь что за запрос вообще, так как токен не должен быть кривым в нормальной ситуации.

статусы ошибок:
{ "status": "error", "payload": { .... } } - общая ошибка, тоесть любые нетиповые ошибки отдают этот статус.
{ "status": "invalid data", "payload": { .... } } - ошибки валидации json схемы(неверный формат передаваемых данных). Обычно мы используем ajv для валидации json схем
{ "status": "invalid token", "payload": { .... } } - сюда относяться все ошибки связанные с JWT, например неправильно сгенерированный ключ
{ "status": "invalid access" } - сюда относяться все ошибки связанные с правами доступа, например попытка войти забаненым профилем.

Обратите внимание, в проектах с повышенной безопасностью, в режимах продакшена, приложения должны выдавать следующие значения 
- просто http код 500, без объяснений - на непредвиденные ошибки
- { "status": "error" }, без разьяснений в payload - разьяснения передают в логи. Пользователь не должен видеть подробной инфы, на все не предусмотренные ошибки.
- { "status": "invalid token" }, без разьяснений в payload - токены выдает наш сервер аутификации, не нужна обычному пользователю инфа почему его токен неправильный.
- вместо { "status": "invalid access" } отдают типовую ошибку 404 - не нужна обычному пользователю информация что по этому url вобще существует закрытый ресурс. Исключение - если проектом предусмотрен шаринг нашего апи и документация по нему есть в открытом доступе. Для случаев когда с апи работает постороння команда - возможно открытие ошибок, но по возможности эта функция привязываеться к конкретным айпи или токенам. 

текущий режим можно проверить
const env = process.env.NODE_ENV;
if (env !== 'development') { .... }

## Типовые мидлвейры для обработки авторизации, ошибок и запросов

### JWT и авторизация
Проверка JWT реализована на уровне сервера, это модули servers/http и servers/ws для ws сервера. Вы можете быть уверены, что если отправили в заголовке JWT, то ключ будет проверен.

Это происходит даже если в текущем запросе это не нужно, JWT проверяеться всегда, если он есть и данные о юзере помещаються в соответствующий раздел(описано далее). Если данных о юзере нет - значит не было и JWT. Запросы с невалидным JWT будут отклонены автоматически.

Если вам нужна оптимизация этого процесса, вы не хотите всегда проверять JWT, а только когда нужно - перенесите мидлвейр из файла настроек сервера в соответствующие роуты. Однако в большинстве случаев, в этом нет необходимости.

Для проверки прав доступа, вы можете использовать мидлвейр auth.
Также *всегда* используйте мидлвейр valid, для проверки коректности формата входящих данных. Даже если ваши данные, это их отсуцтвие.

## Структура проекта

| Файл или папка                 | Что это?
| ------------------------------ | ------------------
| [bin](#bin)                    | скрипты запуска (точки входа и ранеры)
| [config](#config)              | конфиги
| [log](#log)                    | логи
| [logger](#logger)              | логгер для логов
| [models](#models)              | модели бд
| [controllers](#controllers)    | контроллеры
| [routes](#routes)              | роуты http и ws сервера в соответствующих папках. (В зависимости от проекта, могут присутсвовать и другие)
| [schemas](#schemas)            | json схемы для валидации
| [storage](#storage)            | точки доступа к хранилищам (доступ к бд, хранилище сессий и другие)
| [tmp](#tmp)                    | временные файлы (складывайте их сюда чтобы не засорять проект)
| [utils](#utils)                | маленькие скрипты-хелперы, ради которых нет смысла подключать отдельные либы. (Наример функция randInt генерирующая рандомный инт или другие.)

## <a name="bin"></a> bin: скрипты запуска

В этой папке обычно расположены файл www и папка runners.
Файл www это обычно тот файл который запускаеться командой start из package.json.
Файл www обычно без расширения, вместо него используеться специальна строка в файле, "#!/usr/bin/env node", это так называемый shebang. В Unix подобных системах расширение слабо связано с тем какой программой должен быть запущен скрипт, вместо него используют shebang. Возможности shebang не ограничены только этим, но в нашем случае используються именно для этого. Так как большинство серверов работают на Unix подобных системах, shebang решение избавляющее от многих проблем. MacOS - Unix подобная система и тоже использует shebang. Windows игнорирует shebang, но реагирует на команду node прописанную в package.json, с ним никаких проблем.

Кроме www, в этой папке могут быть и другие файлы без расширения, что это за файлы?
имя www подразумевает что вы запускаете веб приложение, но могут быть и другие варианты. Давайте возьмем для примера современный автомобиль, обычный режим запуска автомобиля это езда, но помимо этого у него могут быть  режимы: "в сервисе" - где автомобиль не едет, но разлокируеться часть функций, "паркинг" - где блокируютсья колеса, "авария" - где стреляют подушки и происходить еще бог знает что. Автомобиль один, а режимы использования могут быть разные, точно также и приложения, обычный режим запуска - "веб приложение", сокращенно www, это режим когда приложение просто запускаеться и едит, а помимо этого, могут быть и другие режимы.

Давайте представим что для нормальной нормальной работы вашего веб приложения вам нужно:

* подключиться к базе данных
* поднять http и ws сервер

За каждый этап отвечает маленький микро скрипт - раннер, они соответственно лежат в папке runners, это сделано для того, чтобы избежать дублирования кода, ведь эти же шаги скорее всего будут использовать и другие режимы запуска, также вам будет проще включать или исключать ранеры конктретно для текущего проекта чем переписывать один большой скрипт запуска.

Расмотрим на примере первого шага, у вас есть база данных и вам нужно к ней подключиться. Вы не можете использовать бд пока не подключитесь к ней. То есть у кода компонента условно есть две части:

* Часть которая отвечает за подключение к бд, запускаеться 1 раз и больше никогда не используеться. Эта часть соответствует обычно критериям:
  * запускает процесы внутри вашего компонента, но никак дальше не участвует
  * не относиться к настройкам компонента, которые вы скорее всего будете менять если захотите повтороно использовать код в другом проекте
  * не являеться точкой доступа к функциям компонента
  Не всегда возможно отделить процесы запуска от процеса работы, нет ничего страшного в том если вся эта часть останеться в файле компонента, но следует создать функцию init или что-то аналогичное, и дергать эту функцию из ранера.
* Часть которая используеться в процесе работы, этого недолжно быть в раннере, это находиться в отдельном модуле никак с ранером не связаном.

У вас выйдет, файл www, раннер dbRunner и компонент db.
Файл www дергает нужные ранеры, он огранизовывает последовательность ранеров, если один ранер должен запускаться только после другого, может переддавать какие-то данные между раннерами если это нужно, но никогда не содержит сам код ранера.

`Скорее всего вам будет тяжело сразу понять где ранер, а где компонент, это не так важно, не думайте об этом много, главное само наличие ранера.`

Блокирующие операции.
Вы должны понимать что скрипты запуска приложения это не тоже самое что само приложение, то что происходит при запуске кардинально отличаеться от того как это используют в работе, потому и правила тут другие. При запуске допустимы, а где-то и вовсе необходимы, блокирующие операции.

## <a name="config"></a> config: конфиги

Любые общие конфиги, в том числе конфиги, которые генерирующиеся на основе алгоритмов, но дающие на выходе простые объекты, должны быть тут.

На выходе их модуля конфигов вы получаете простой объект. Объект зафризен, во избежания случайных изменений.

Любой .js файл в этом каталоге, кроме index.js, становиться конфигом. Если вы создаете файл app.js, то файл должен отдавть нарружу объект и этот объект автоматически станет ключем в общем конфиге. Тоесть имея файл app.js и server.js, в суме вы получите конфиг в формате { app: {<ваши конфиги>}, server: {<ваши конфиги>} }. То есть имя ключа соответствует имени файла.

в прошлых версиях BaseApp мы оставляли возможность в одном конфиге делать несколько ключей. Это возможность уже доллго не использовалась и в основном она нужна была для костыей, потмоу мы ее убрали в новых версиях.

Еще раз, как этим пользоваться?
К примеру у вас в папке config есть файлы server.js и db.js. Это значит что у вас есть два объекта которые экспоритируют каждый из этих файлов, например:
server.js
module.exports = {
  port: 8080
}

и

db.js
module.exports = {
  uri: 'mongodb://localhost:27017/myapp'
}

Внутренний алгоритм конфигов соеденит эти два массива в один:
{
  server: {
    port: 8080
  },
  db: {
    uri: 'mongodb://localhost:27017/myapp'
  }
}

После чего фризит(deepFreeze) объект для защиты от изменений и снова экспоритует. 

Это и будет конфиг вашего приложения, чтобы получить к нему доступ используеться обычный синтаксис node.js.
К примеру вам нужен порт из настроек сервера, его можно получить так:
const { port } = require('config').server;

о консольных аргументах и переменных окружения(NODE_ENV и другие).
Ранее мы также делали их частью конфига, то-есть к примеру переменную NODE_ENV мы получали как часть конфигурации
const port = require('config').NODE_ENV, но мы перестали так делать, так как это создавало некоторые проблемы и не давало особой выгоды. Потому мы приняли некоторые соглашения:

* NODE_ENV используються как есть, то-есть их получают напрямую из process.env
* Не стандартные переменные окружения, то-есть те что вы придумали сами, включая и те что имеют типовые названия, должны быть получены из process.env внутри модуля config и помещены в какойто раздел, в дальнейшем с их полученают с этого раздела.

Например, во многих учебных примерах и даже боевых проектах, порт для http сервера передаеться чкркз переменную окружения PORT, прямо в строке запуска. Но мы не делаем так. Это работает хорошо только для сугубо http приложений или учебных проектов.

Что вы должны сделать в нашем случае:
1. У вас должен быть файл конфигов сервера, в папке config. например этот файл называеться server.js
2. В файле server.js вы получаете порт из переменной окружения, в обычную переменную, например так:

> const port = process.env.PORT;

3. Нужно провалидировать данные и привести к верному формату. Порт должен быть Int, но к вам прийдет string, так как из консоли вам всегда приходит string. Нужно перевести его в numeric, так как имено типа данных Int в Node.js нет, и удостовериться что это валидный порт:

const normalizePort = (port) => { .... } // Функция которая сделает проверку и нормализацию порта
const port = normalizePort(process.env.PORT);

Вам также следует указать порт по умолчанию, для этого добавим или
> const normalizePort = (port) => { .... } // Функция которая сделает проверку и нормализацию порта
> const port = normalizePort(process.env.PORT) || 3000;;

После выпомещаете полученные данные в объект, который експортирует файл server.js:
> const normalizePort = (port) => { .... } // Функция которая сделает проверку и нормализацию порта
> const port = normalizePort(process.env.PORT) || 3000;
>
> module.exports = {
>   http: {
>     port,
>   },
> };

В дальнейшем, когда http сервер получит порт из конфигов, напомню
const { port } = require('config').server.http;
У сервера нет необходимости думать о том, откуда взялся этот порт и коректен ли он, он просто его использует.
Вы никогда не должны получать конфиги мимо модуля config, так как это нарушит принцип единой точки входа для конфигов, что может привести к непредсказуемым последствиям и путанице.

Использование других компонентов внутри конфигов?
Этого не стоит делать, у модуля config уникальная ситуация, он нужен для работы практически любого другого модуля. Используйте это с осторожностью. Особено избегайте использование асинхронных модулей, в нем можно сделать логику подгрузки, но пока этого нет.

Если у модуля нет зависимостей от config, я могу использовать его в процесе иницыализации?

Только если вы понимаете что делаете, если вы сделаете так, скорее всего вы больше не сможете использовать config для хранения конфигураций этого модуля, если в будущем они у него появяться.

Асинхронные операции внутри конфилов?
Вы должны понимать что конфиг это первое что иницыализируеться при старте приложения, он не должен пропускать любой другой код впереди себя. Мы могли бы добавить сюда возможность использовать промисы, но это в значительной мере усложнит код и пока в этом небыло необходимости. Возможно в будущем. Не используйте асинхронные операции, благо почти любому асинхронному действию, есть синхронный аналог, а блокирующие операции в конфигах допустимы, как части иницыализации всего приложения.

## <a name="log_logger"></a> log и logger: логи и логгер для логов
Наш нативный логер значительно устарел и бажит безбожно из-за множества изменений. Я пишу эту это тут для себя, чтобы помнить о необходимости его переписать.

**!не весь функционал пока реализован в новом логере, но все эти возможности будут доступны позже**

Что такое вообще логер?
Обычно что того чтобы что-то написать в консоль часто используют console.log или другие методы объекта console. Это делают для любых оповещений, важных, неважных, так и кратких заметок. Мы зачатую тоже используем console.log, потому что это удобно. Однако есть два существенных нюанса:
- console.log не пишет имя файла и строку, с которой ее вызвали, так как это весьма тяжелая операция и на беке она по умолчанию отключена.
- когда приложение загрузят на сервер - консоль никто не видит и она не будет кудато сохраняться без спыциальных настроек.
  
Логер это специальный модуль, замена стандартному консоль логу. Он даже может быть встроен и стандарнтый console.log благодаря функциям Proxy, собственно наш предыдущий логер так и делал, новый пока не умеет.

Чем отличаеться логер от обычного console.log?

- Логер показывает откуда была вызвана консоль. Умеет прятать данные, когда приложение уже залито на реальный сервер и работает в режиме продакшена, чтобы не нагружать дополнительно сервер. К примеру от умеет показывать откуда былетела ошибка, даже если там не было сделано new Error().
- Имеет множество дополнений, например prettyPrint, который красиво форматирует строки консоли
- Логер не прячем слишком большие объекты. Это важно для поиска ошибок в логах
- Логер выводит сообщения в типовом формате для логов(напишу стандарт как вспомню). Стандартизированые вещи это всегда хорошо, так как их легко при необходимости стыковать с дополнительным софтом.
- Логер умеет делать роутинг логов, это когда он старые логи автоматически архивирует, чтобы не было огромных тектовых файлов на 20 гигабайт, где все консоль логи за несколько лет. (в пино это предлагаеться делать внешним софтом, я тоже за это, потмоу в текущем логере мы не будет использовать этого. Смотрите доку по ротации в [pino|https://www.npmjs.com/package/pino/v/3.0.0#how-do-i-rotate-log-files])
- Логер поддерживает транспорты. Транспорт это возможность отправлять логи не только в консоль, но куда скажите. Например на удаленный сервер или еще куда.

Все написанное выше, это что делает логер, по крайней мере то что мы использовали в старом логере, когда он был свеж и нов, и работал без ошибок. Детали в разных логерах могут отличаться, но в целом, логер это продвинутая console.log().

## <a name="models"></a> models: модели бд

## <a name="routes"></a> httpRoutes и wsRoutes: роуты http сервера и роуты ws сервера

## <a name="schemas"></a> schemas: точки доступа к хранилищам

## <a name="storage"></a> storage: точки доступа к хранилищам

## <a name="tmp"></a> tmp: временные файлы

## <a name="utils"></a> utils: скрипты-хелперы
